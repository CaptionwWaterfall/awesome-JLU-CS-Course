
int GraphList::DFS(const int v0,const int v2)                    //判断两个点是否连通
{
    int * visited=new int[graphsize];
    for(int i=0;i<graphsize;i++)
        visited[i]=0;
    visited[v0]=1;
    queue<int> q;
    q.push(v0);
    while(!q.empty())
    {
        int v;
		v=q.front();
        q.pop();

        Edge * p=head[v].adjacent;
        while(p!=NULL)
        {
            int w=p->VerAdj;
            if(visited[w]!=1)
            {
                if(w==v2)
                    return 1;
                visited[w]=1;
                q.push(w);
            }
            p=p->link;
        }
    }
    delete[]visited;
    return 0;
}




void printToFile(GraphList aaa,FILE * fp)  //文件输出
{
  
    for(int i=0;i<aaa.graphsize;i++)
    {
        int temp;
        if(aaa.head[i].adjacent!=NULL)
        {
            fputs("node ",fp);
            fprintf(fp,"%d",i+1);
            fprintf(fp,"%c",':');
            Edge * p =aaa.head[i].adjacent;
            while(p->link!=NULL)
            {
                temp=p->VerAdj;
                fprintf(fp,"%d",temp+1);
                fprintf(fp,"%c",'-');
                fprintf(fp,"%c",'>');
                p=p->link;
            }
            temp=p->VerAdj;
            fprintf(fp,"%d",temp+1);
            fprintf(fp,"%c",'\n');
        }
    }

}




void citymust(GraphList aaa)                                  //第三问两种情况的重要城市
{
 cout<<"现在寻找需要交换机的重要城市\n\n";
	  int  * citymust=new int(50);
	  int musttotol=0;

	  for(i=0;i<n;i++)
	  {
		  int flag=0;
		  int dv[1000] ;//记录删过的边；
		  int x=0;
		  Edge * p=aaa.head[i].adjacent;
		  if(p!=NULL)
		  
		{

			  
		    while(p!=NULL)
			{
			  
			  dv[x]=p->VerAdj;
			  x++;
			  aaa.DelEdge(i,p->VerAdj);
			  aaa.DelEdge(p->VerAdj,i);
			  p=aaa.head[i].adjacent;

			}
		  

		    int j,r;

		    for(j=1;j<n;j++)
			{
			  for(r=0;r<j;r++)
			  {
			    if(j!=i&&r!=i)
				{
                  if(aaa.DFS(j,r)==0)  cout<<i+1<<"是重要城市"<<endl;
				
				}
			  }
			  if(flag==1) break;
			}

		  for(x=x-1;x>=0;x--)
		  {
                  aaa.InsertEdge(i,dv[x]);
		  aaa.InsertEdge(dv[x],i);
		  }
		
		}
		  
		}
           char ch;
    

	  cout<<"现在寻找需要交换机的重要城市\n\n";      //寻找需要交换机的重要城市
	  int  * citymust2=new int(50);
	  int musttotol2=0;
	  int liantong2[50][50];

	  for(i=0;i<2*aaa.edgenumber2;i+=2) 
	  {
		  aaa.DelEdge(aaa.edge2[i],aaa.edge2[i+1]);
		  aaa.DelEdge(aaa.edge2[i+1],aaa.edge2[i]);
	  }

	  for(i=0;i<n;i++)
	  {
		  int flag=0;
		  int * dv=new int ;//记录删过的边；
		  int x=0;
		  Edge * p=aaa.head[i].adjacent;
		  if(p->link!=NULL)
		  
		{

			  
		    while(p->link!=NULL)
			{
			  
			  dv[x]=p->VerAdj;
			  x++;
			  aaa.DelEdge(i,p->VerAdj);
			  aaa.DelEdge(p->VerAdj,i);
			  p=aaa.head[i].adjacent;

			}

		  int j,r;

		  for(j=1;j<n;j++)
		  {
			  for(r=0;r<j;r++)
			  {
			    if(j!=i&&r!=i)
				{
                  if(aaa.DFS(j,r)!=1)
				  {
					  cout<<i+1<<"是重要城市"<<endl;
					  flag=1;
					  citymust2[musttotol2]=i+1;
					  musttotol2++;
					  break;
				  }
				}
			  }
			  if(flag==1) break;
		  }

		for(x=x-1;x>=0;x--)
		{
          aaa.InsertEdge(i,dv[x]);
		  aaa.InsertEdge(dv[x],i);
		}
		p=p->link;
		  }
		  
	  }

	  

	   printToFile(aaa,file);//第二问文件保存

}