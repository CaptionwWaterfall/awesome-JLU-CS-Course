#include <graphics.h>
#include <iostream>
#include <conio.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include <queue>
#include <stack>
#include <time.h>
#include <string.h>
using namespace std;
double PI = 3.14159265358979323846;
int MaxVertex=1000;
int Max=1000;





void huaxian(int i,int j,int n)    // 画线
{
	int x1,x2,y1,y2;
	x1=200*cos(i*2*PI/n)+350;
	y1=200*sin(i*2*PI/n)+300;

	x2=200*cos(j*2*PI/n)+350;
	y2=200*sin(j*2*PI/n)+300;

	line(x1,y1,x2,y2);				

}



void huadian(int n)                    //画点
{
	char num[2];
	int i;
	
	for(i=1;i<=n;i++)
	{
      int x,y;
	  x=200*cos(i*2*PI/n)+350;
	  y=200*sin(i*2*PI/n)+300;
	  circle(x, y, 30);
	  sprintf(num, "%d", i);
      outtextxy(x , y , num);

	}

}




void filldian(int i,int n)                  //显示重要城市的图形界面
{
	  int x,y;
	  x=200*cos(i*2*PI/n)+350;
	  y=200*sin(i*2*PI/n)+300;
      fillcircle(x, y, 30);
}






struct Edge
{
	friend class GraphList;
	int VerAdj;
	int cost;
	Edge * link;
};


struct Vertex
  {
	friend class GraphList;
	int VerName;
	Edge * adjacent;
  };




class GraphList
{
    public:
		  int graphsize;
		  Vertex * head;
		  int edgenumber1;  //正常的线的数量
		  int edgenumber2;  //冗余的线的数量
		  int e;            //线的总数量
		  int * edge1;
		  int * edge2;
          void Create();    //创建随机网络
		  int  DFS(const int v0,const int v2) ;         //判断两个点是否连通

		  GraphList(int n=0,int m=0)
		  {
			  edgenumber1=0;
		      edgenumber2=0;
			  edge1=new int[MaxVertex];
		      edge2=new int[MaxVertex];
			  e=m;
		      graphsize=n;
		      head=new Vertex[MaxVertex];

		  }

		  void qingkong(int n=0,int m=0)
		  {
			  edgenumber1=0;
		      edgenumber2=0;
			  edge1=new int[MaxVertex];
		      edge2=new int[MaxVertex];
			  e=m;
		      graphsize=n;
		      head=new Vertex[MaxVertex];
		  }

		 int GetWeight(int  v1,int  v2)
		  {
		      if(v1<0||v2<0) return 0;
		      Edge * p=head[v1].adjacent;
		      while(p!=NULL)
              {
                  if(p->VerAdj==v2) return 1;
                  p=p->link;
              }
              return 0;
		  }

          void BFS(int v)
		  {
	          int  visited[1000];
	          int i;
	          for(i=0;i<graphsize;i++) visited[i]=0;

	          queue <int >qq;

	          visited[v]=1;
	          qq.push(v);
	          while( !qq.empty() )
              {
                  int x=qq.front();
                  cout<<"["<<x+1<<"]  ";
                  qq.pop();
                  Edge * p=head[x].adjacent;
                  while(p!=NULL)
                  {
                      if(visited[p->VerAdj]==0)
                      {
                          visited[p->VerAdj]=1;
                          qq.push(p->VerAdj);
                      }
                      p=p->link;
                  }
              }

		  }


	      int GetNeighbor(int v)
	      {
	          if(v<0) return -1;
	          Edge * p=head[v].adjacent;
	          if(p!=NULL) return p->VerAdj;
	          else return -1;
	      }



          void InsertEdge(int v1,int v2)
		  {
    
             Edge*p=new Edge;
             p->VerAdj=v2;
             p->cost=1;
             p->link=NULL;
             Edge* q=head[v1].adjacent;
             if(q==NULL)
                   head[v1].adjacent=p;
             else if(q!=NULL)
			 {
               if(q->link==NULL)
			   {
                q->link=p;
			   }
               else if(q->link!=NULL)
			   {
                while(q->link!=NULL)
                {
                q=q->link;
                }
                q->link=p;
			   }
			 }


		  }

int GetFirstNeighbor(const int v)
{
    if(v==-1)return -1;
    Edge* p=head[v].adjacent;
    if(p!=NULL)
        {
        return p->VerAdj;
        }
    else return -1;
}


void DelEdge(int from,int to)
	      {
                Edge * p=head[from].adjacent;
				if(p->VerAdj==to)  head[from].adjacent=p->link;
				
				else
				{
                while(p->link!=NULL)
                {
                      if(p->link->VerAdj==to)
                      {
                          Edge * q=p->link;
                          p->link=q->link;
                          delete q;
                      }
					  else p=p->link;
                  }
				}

          }


  };



  void GraphList::Create()                              //创建随机网络
        {
            int i=0,from,to;
            for(i=0;i<graphsize;i++)
            {
                head[i].VerName=i;
                head[i].adjacent=NULL;
            }


            i=0;

	        srand((unsigned) time(NULL));
			
            while(i<e)
            {
		       from=rand()%(graphsize);
		       to=rand()%(graphsize);
		       if((from==to)||(GetWeight(from,to)==1)) cout<<"不是边或者已经存在此边"<<endl;
		       else
		       {
		           i++;

			      if(DFS(from,to)==1)
                  {
					  edgenumber2++;
                      edge2[2*edgenumber2-2]=from;
                      edge2[2*edgenumber2-1]=to;
                  }
				  else
				  {
					  edgenumber1++;
                      edge1[2*edgenumber1-2]=from;
                      edge1[2*edgenumber1-1]=to;

				  }
                Edge * p=new Edge;
                p->VerAdj=to;
                p->cost=1;
                p->link=NULL;
                Edge * q=head[from].adjacent;
                if(q==NULL)
                {head[from].adjacent=p;}
                else
                {
                    while(q->link!=NULL) q=q->link;
                    q->link=p;
                }

                p=new Edge;
                p->VerAdj=from;
                p->cost=1;
                p->link=NULL;
                q=head[to].adjacent;
                if(q==NULL)
                {head[to].adjacent=p;}
                else
                {
                    while(q->link!=NULL) q=q->link;
                    q->link=p;
                }



               }
             }
        }


int GraphList::DFS(const int v0,const int v2)                    //判断两个点是否连通
{
    int * visited=new int[graphsize];
    for(int i=0;i<graphsize;i++)
        visited[i]=0;
    visited[v0]=1;
    queue<int> q;
    q.push(v0);
    while(!q.empty())
    {
        int v;
		v=q.front();
        q.pop();

        Edge * p=head[v].adjacent;
        while(p!=NULL)
        {
            int w=p->VerAdj;
            if(visited[w]!=1)
            {
                if(w==v2)
                    return 1;
                visited[w]=1;
                q.push(w);
            }
            p=p->link;
        }
    }
    delete[]visited;
    return 0;
}


void printToFile(GraphList aaa,FILE * fp)
{
  
    for(int i=0;i<aaa.graphsize;i++)
    {
        int temp;
        if(aaa.head[i].adjacent!=NULL)
        {
            fputs("node ",fp);
            fprintf(fp,"%d",i+1);
            fprintf(fp,"%c",':');
            Edge * p =aaa.head[i].adjacent;
            while(p->link!=NULL)
            {
                temp=p->VerAdj;
                fprintf(fp,"%d",temp+1);
                fprintf(fp,"%c",'-');
                fprintf(fp,"%c",'>');
                p=p->link;
            }
            temp=p->VerAdj;
            fprintf(fp,"%d",temp+1);
            fprintf(fp,"%c",'\n');
        }
    }

}









int main()
 {
	FILE * file;
	file=fopen("text.txt","w");
	int m,n,i,j;
	int liantongxing=1;
	cout<<"please input n:"<<endl;
    cin>>n;
	cout<<"please input m:"<<endl;
    cin>>m;
	GraphList aaa(n,m);
	aaa.Create();
	for(i=1;i<n;i++)
	{
		  for(j=0;j<i;j++)
		  {
			  if(aaa.DFS(i,j)==0) liantongxing=0;
		  }
	 }

	if(liantongxing==0)
	{
		int liantongxing=1;
		cout<<"输入不符合要求请重新输入";
		cout<<"please input n:"<<endl;
        cin>>n;
	    cout<<"please input m:"<<endl;
        cin>>m;
		aaa.qingkong(n,m);
	    aaa.Create();
	    for(i=1;i<n;i++)
		{
		  for(j=0;j<i;j++)
		  {
			  if(aaa.DFS(i,j)==0) liantongxing=0;
		  }
		}
		
	}

	


	
    

	  int kekaoxing=1;
	  cout<<"现在验证可靠性"<<endl;
	  for(i=0;i<2*aaa.edgenumber1;i+=2)
	  {
		  int a=aaa.edge1[i];
		  int b=aaa.edge1[i+1];
		  cout<<a+1<<"    "<<b+1<<endl;
		  aaa.DelEdge(a,b);
		  aaa.DelEdge(b,a);
		  if(aaa.DFS(a,b)==0) 
		  {
			  cout<<"不可靠，若"<<a+1<<"-->"<<b+1<<"断掉，则全部中断"<<endl;
			  aaa.InsertEdge(a,b);
		      aaa.InsertEdge(b,a);
			  kekaoxing=0;
		      break;
		  }
		 aaa.InsertEdge(a,b);
		 aaa.InsertEdge(b,a);
		 cout<<"已加入"<<a+1<<b+1<<endl;
		 cout<<endl;

	 }


	  if(kekaoxing==1) cout<<"可靠\n";cout<<endl<<endl;


	  cout<<"现在寻找需要交换机的重要城市\n\n";
	  int  * citymust=new int(50);
	  int musttotol=0;

	  for(i=0;i<n;i++)
	  {
		  int flag=0;
		  int dv[1000] ;//记录删过的边；
		  int x=0;
		  Edge * p=aaa.head[i].adjacent;
		  if(p!=NULL)
		  
		{

			  
		    while(p!=NULL)
			{
			  
			  dv[x]=p->VerAdj;
			  x++;
			  aaa.DelEdge(i,p->VerAdj);
			  aaa.DelEdge(p->VerAdj,i);
			  p=aaa.head[i].adjacent;

			}
		  

		    int j,r;

		    for(j=1;j<n;j++)
			{
			  for(r=0;r<j;r++)
			  {
			    if(j!=i&&r!=i)
				{
                  if(aaa.DFS(j,r)==0)
				  {
					  cout<<i+1<<"是重要城市"<<endl;
					  flag=1;
					  int uu=i+1;
					  citymust[musttotol]=uu;
					  musttotol++;
					  break;
				  }
				}
			  }
			  if(flag==1) break;
			}

		  for(x=x-1;x>=0;x--)
		  {
          aaa.InsertEdge(i,dv[x]);
		  aaa.InsertEdge(dv[x],i);
		  }
		
		}
		  
		}
       char ch;

	  getch();
	  initgraph(700,600);				// 初始化 640 x 480 的绘图窗口
	  setwritemode(R2_XORPEN);			// 设置 XOR 绘图模式
	  setfillcolor(0x24c097);
	  huadian(aaa.graphsize);
	  setlinecolor(GREEN);					// 设置画线颜色为红色
	  for(i=0;i<2*aaa.edgenumber1;i+=2)
	  {
		  huaxian(aaa.edge1[i]+1,aaa.edge1[i+1]+1,aaa.graphsize);
		  
	  }
      
      
       setlinecolor(RED);					// 设置画线颜色为红色
	   for(i=0;i<2*aaa.edgenumber2;i+=2)
	   {
		   huaxian(aaa.edge2[i]+1,aaa.edge2[i+1]+1,aaa.graphsize);
		   
	   }
	   getch();

      int i1;
	  for(i1=0;i1<musttotol;i1++)
	  {
		  filldian(citymust[i1],aaa.graphsize);
	  }
	  saveimage("text1.bmp");

      
	  getch();

	   closegraph();						// 关闭绘图窗口




	  cout<<"现在寻找需要交换机的重要城市\n\n";
	  int  * citymust2=new int(50);
	  int musttotol2=0;
	  int liantong2[50][50];

	  for(i=0;i<2*aaa.edgenumber2;i+=2) 
	  {
		  aaa.DelEdge(aaa.edge2[i],aaa.edge2[i+1]);
		  aaa.DelEdge(aaa.edge2[i+1],aaa.edge2[i]);
	  }

	  for(i=0;i<n;i++)
	  {
		  int flag=0;
		  int * dv=new int ;//记录删过的边；
		  int x=0;
		  Edge * p=aaa.head[i].adjacent;
		  if(p->link!=NULL)
		  {

			  
		    while(p->link!=NULL)
			{
			  
			  dv[x]=p->VerAdj;
			  x++;
			  aaa.DelEdge(i,p->VerAdj);
			  aaa.DelEdge(p->VerAdj,i);
			  p=aaa.head[i].adjacent;

			}

		  int j,r;

		  for(j=1;j<n;j++)
		  {
			  for(r=0;r<j;r++)
			  {
			    if(j!=i&&r!=i)
				{
                  if(aaa.DFS(j,r)!=1)
				  {
					  cout<<i+1<<"是重要城市"<<endl;
					  flag=1;
					  citymust2[musttotol2]=i+1;
					  musttotol2++;
					  break;
				  }
				}
			  }
			  if(flag==1) break;
		  }

		for(x=x-1;x>=0;x--)
		{
          aaa.InsertEdge(i,dv[x]);
		  aaa.InsertEdge(dv[x],i);
		}
		p=p->link;
		  }
		  
	  }

	  getch();
	  initgraph(700,600);				// 初始化 640 x 480 的绘图窗口
	  setwritemode(R2_XORPEN);			// 设置 XOR 绘图模式
	  setfillcolor(0x24c097);
	  huadian(aaa.graphsize);
	  setlinecolor(GREEN);					// 设置画线颜色为红色
	  for(i=0;i<2*aaa.edgenumber1;i+=2) huaxian(aaa.edge1[i]+1,aaa.edge1[i+1]+1,aaa.graphsize);
      getch();
      int i2;
	  for(i2=0;i2<musttotol2;i2++)
	  {
		  filldian(citymust2[i2],aaa.graphsize);
	  }
	  saveimage("text2.bmp");
      
	  getch();


	   closegraph();						// 关闭绘图窗口
 printToFile(aaa,file);//第二问文件保存
	   fclose(file);

	  

 	   return 0;
}


