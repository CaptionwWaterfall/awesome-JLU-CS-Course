#include <iostream.h>

class T
{
public:
	T(int a=0,int b=-1) {xishu=a;mishu=b;}
	~T() {}
	int xishu;
	int mishu;
	void out()
	{
		cout<<xishu<<"X^"<<mishu;
	}

}; 

struct SLNode
{
	T data;
	SLNode * next;
	SLNode(const T& item=NULL,SLNode * nextNode=NULL)
	{
		data=item;
		next=nextNode;
	}
};


class SLList
{
public:
	SLNode * head;       //哨兵指针
	SLNode * tail;       //尾指针
	SLNode * p;          //用于操作的一个指针
	int size;            //链表长度
public:
//构造
	SLList()
	{
		head=tail=p=new SLNode();
		size=0;
	}



//析构
	~SLList() 
	{
		p=head->next;
		while(p!=NULL)
		{
			SLNode * ptr=p;
			p=p->next;
			delete ptr;
		}
		delete head;
	}



//向尾部添加
	void addToTail(const T & item)
	{
			tail->next=new SLNode(item,NULL);
	    	tail=tail->next;
		    size++;
	}

	//向第k个节点后插入节点（哨兵节点为第0个） 
	void Insert(int k,const T& item)
	{
       if(k<0)
	   {
	      cout<<"插入不合法!"<<endl ; 
	   }
	   else
	   {
	   SLNode * ptr=head->next  ;
	   SLNode * p1=new SLNode(item) ;
	   int i=1 ;
	   if(k==0)
	   {
		   
		   p1->next=head->next;
  		   head->next=p1 ;
	   }
	   else
	   {
		   while((i<k)&&(ptr!=NULL))
		   {
			   ptr=ptr->next ;
               i=i+1 ;
		   }
		   p1->next=ptr->next;
  		   ptr->next=p1 ;
	   }
       
       size++;
	   }
}




//是否为空链表
	bool IsEmpty()
	{
		return head->next==NULL;
	}

//删除当前指针,无需遍历
	void deleteNowptr()
	{
        if(IsEmpty())
		{
		    cout<<"空表"<<endl;
		}
		else
		{
		p->data=(p->next)->data;
		p->next=(p->next)->next;
		size--;
		}
	}


//输出全体（除了哨兵节点）
	void output()
	{
		p=head->next;
                p->data.out();
                p=p->next;
		while (p!=NULL)
		{
			if(p->data.xishu>0)
			{
				cout<<"+";
			}
			
            p->data.out();
			
			p=p->next;
			
		}
		cout<<endl;
	}

//储存K
	void Find(int k ,T & item )
	{
       if(k<1) cout<<"no no no!"<<endl;
	   else
	   {
		   p=head;
		   int i=0;
		   while(p!=NULL&&i<k)
		   {
			   p=p->next;
			   i=i+1;
		   }
		   item=p->data;
	   }
	}









};





int main()
{
	SLList a,b;
	T TA5(3,10);
        T TA1(5,7);
	T TA2(3,4);
	T TA3(2,2);
	a.addToTail(TA5);
	a.addToTail(TA1);
	a.addToTail(TA2);
	a.addToTail(TA3);
	T TB1(-10,7);
	T TB2(2,5);
	T TB3(1,0);
	b.addToTail(TB1);
	b.addToTail(TB2);
	b.addToTail(TB3);

	a.output();
	b.output();

	a.p=a.head->next;
	b.p=b.head->next;

    for(int i=1;i<a.size;i++)
	{
		while((b.p->data.mishu)>=(a.p->data.mishu))
		{
			if((b.p->data.mishu)==(a.p->data.mishu))
			{
				a.p->data.xishu=(a.p->data.xishu)+(b.p->data.xishu);
				
			}
			if((b.p->data.mishu)>(a.p->data.mishu))
			{
				a.Insert(i-1,b.p->data);
				i++;
				
			}
			
			b.p=b.p->next;
			if(b.p==NULL) 
			{
				a.output();
				cout<<"over";
				return 0;
			}
			
		}
		a.p=a.p->next;
	}



	while(a.p->next==NULL&&b.p!=NULL)
	{
		a.addToTail(b.p->data);
		b.p=b.p->next;
	}               //如果B的多项式有余项，添加到A的尾部

	a.output();
		
	

	return 0;

}